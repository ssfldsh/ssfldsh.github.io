<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>层次化聚类 | RunZhe He&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="实验要求：1． 理解接层次化聚类的原理和作用。理解层次化聚类中的距离和“松散度”的概念。 2． 实现层次化聚类的全过程流程，包括与用户的交互、树结构的建设和存储、与数据库的交互、核心聚类算法实现等。 3． 具体要求：实现一个具有一定“通用性”的软件，可以针对数据库的不同字段的取值人工建树，建好的树可以组合复用，进行层次化聚类，并能显示聚类结果。要求数据库路径可以配置，或在界面中输入。 4． 本实验">
<meta property="og:type" content="article">
<meta property="og:title" content="层次化聚类">
<meta property="og:url" content="http://example.com/2020/03/12/%E5%B1%82%E6%AC%A1%E5%8C%96%E8%81%9A%E7%B1%BB/index.html">
<meta property="og:site_name" content="RunZhe He&#39;s Blog">
<meta property="og:description" content="实验要求：1． 理解接层次化聚类的原理和作用。理解层次化聚类中的距离和“松散度”的概念。 2． 实现层次化聚类的全过程流程，包括与用户的交互、树结构的建设和存储、与数据库的交互、核心聚类算法实现等。 3． 具体要求：实现一个具有一定“通用性”的软件，可以针对数据库的不同字段的取值人工建树，建好的树可以组合复用，进行层次化聚类，并能显示聚类结果。要求数据库路径可以配置，或在界面中输入。 4． 本实验">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%89.png">
<meta property="og:image" content="http://example.com/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%892.png">
<meta property="og:image" content="http://example.com/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%893.png">
<meta property="og:image" content="http://example.com/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%894.png">
<meta property="article:published_time" content="2020-03-12T14:26:41.000Z">
<meta property="article:modified_time" content="2021-07-20T15:03:29.068Z">
<meta property="article:author" content="RunZhe He">
<meta property="article:tag" content="数据挖掘">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%89.png">
  
    <link rel="alternate" href="/atom.xml" title="RunZhe He's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RunZhe He&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-层次化聚类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/12/%E5%B1%82%E6%AC%A1%E5%8C%96%E8%81%9A%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2020-03-12T14:26:41.000Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      层次化聚类
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h1><p>1． 理解接层次化聚类的原理和作用。理解层次化聚类中的距离和“松散度”的概念。</p>
<p>2． 实现层次化聚类的全过程流程，包括与用户的交互、树结构的建设和存储、与数据库的交互、核心聚类算法实现等。</p>
<p>3． 具体要求：实现一个具有一定“通用性”的软件，可以针对数据库的不同字段的取值人工建树，建好的树可以组合复用，进行层次化聚类，并能显示聚类结果。要求数据库路径可以配置，或在界面中输入。</p>
<p>4． 本实验要求计算最优解，除了穷举没有更好的办法（据老王所知），特别注意层次化聚类算法中的剪枝操作，否则你的软件会异常缓慢。</p>
<span id="more"></span>

<h1 id="实验内容："><a href="#实验内容：" class="headerlink" title="实验内容："></a>实验内容：</h1><h2 id="1．实验背景介绍"><a href="#1．实验背景介绍" class="headerlink" title="1．实验背景介绍"></a>1．实验背景介绍</h2><p>层次化聚类是数据挖掘中的一个重要的组成部分。有很多近似算法，也就是不要求求得最优解，包括自底向上的合并算法和自顶向下的分解算法。这次实验要求求得精确解。</p>
<h3 id="（一）层次树和数据"><a href="#（一）层次树和数据" class="headerlink" title="（一）层次树和数据"></a><strong>（一）层次树和数据</strong></h3><p>假设我们有如下几棵层次树：</p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%89.png"></p>
<p>图1 日期层次树</p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%892.png"></p>
<p>图2 时间层次树</p>
<p> <img src="/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%893.png"></p>
<p>图3 老人类型层次树</p>
<p>又假设我们有如五条表示老年人购物的数据（称为数据集U）：</p>
<p>1 （周一，上午劳作时，行动老人，80）</p>
<p>2 （周二，上午劳作时，行动老人，90）</p>
<p>3 （周六，上午劳作时，活力老人，120）</p>
<p>4 （周日，下午劳作时，活力老人，100）</p>
<p>5 （周五，晚休闲，地上行动老人，70）</p>
<p>其中，第1条数据表示的意思是：在周一，在上午工作时间，有一个“行动老人”，花了80元钱在商场购物；其它4条信息类似。最后的数字称为“主题值”。</p>
<h3 id="（二）抽象事件、基础抽象事件、抽象事件之间覆盖关系和距离"><a href="#（二）抽象事件、基础抽象事件、抽象事件之间覆盖关系和距离" class="headerlink" title="（二）抽象事件、基础抽象事件、抽象事件之间覆盖关系和距离"></a><strong>（二）抽象事件、基础抽象事件、抽象事件之间覆盖关系和距离</strong></h3><p>各棵树之中任选一个节点，构成的向量叫做“<strong>抽象事件</strong>”。例如，（日期，劳作时，地上心动老人）就是一个抽象事件，（周六，上午劳作时，活力老人）也是一个抽象事件</p>
<p>如果抽象事件向量的各个分量都是层次化树的叶子节点，则称为“<strong>基础抽象事件</strong>”。例如，（周六，上午劳作时，活力老人）就是一个基础抽象事件，但是，（日期，劳作时，地上心动老人）并不是一个基础抽象事件，因为前两个分量并不是叶子节点。</p>
<p>同一棵树中，具有祖先-子孙关系的两个节点具有“<strong>覆盖关系</strong>”。例如，在层次化树“老人类型”中，节点“老人类型”覆盖了“老人类型”节点，也覆盖了其它任何节点，“心动老人”节点覆盖了“地上心动老人”节点。但是，节点“行动老人”节点并没有覆盖“地上心动老人”节点。</p>
<p>如果两个节点具有覆盖关系，则二者之间可以定义距离：他们之间边的总数。例如，节点“老人类型”覆盖了节点“老人类型”，二者之间的距离是0；节点“老人类型”覆盖了节点“床上心动老人”，则二者的距离是2。</p>
<p>对于两个抽象事件，如果A抽象事件的各个分量覆盖了B抽象事件的各个分量，则称A抽象事件“<strong>覆盖</strong>”了B抽象事件。例如，（日期，时间，老人类型）能覆盖自身，也能覆盖所有的其它抽象事件。又例如，（周五，晚休闲，心动老人）能覆盖（周五，晚休闲，地上心动老人）。但是，（工作日，休闲时，行动老人）不能覆盖（周六，午休闲，行动老人），因为第一个抽象事件的第一个分量不能覆盖第二个抽象事件的对应分量。</p>
<p>如果两个抽象事件之间具有覆盖关系，则二者之间可以定义距离：分量之间距离的平均值。例如，（周五，晚休闲，心动老人）能覆盖（周五，晚休闲，地上心动老人），则二者之间的距离是（0 + 0 + 1）&#x2F; 3 &#x3D; 1&#x2F;3。</p>
<h3 id="（三）覆盖集"><a href="#（三）覆盖集" class="headerlink" title="（三）覆盖集"></a><strong>（三）覆盖集</strong></h3><p>给定若干个基础抽象事件构成的集合E，给定一个抽象事件A，则A能够覆盖的E中的基础抽象事件的集合F，称为A的覆盖集。</p>
<p>例如，给定具有5条基础抽象数据的数据集U，以及抽象事件A &#x3D; （工作日，劳作时，行动老人），则它可以覆盖1、2量条数据，因此A的覆盖集是{1，2}。</p>
<h3 id="（四）最小覆盖"><a href="#（四）最小覆盖" class="headerlink" title="（四）最小覆盖"></a><strong>（四）最小覆盖</strong></h3><p>给定一个基础抽象事件集F，一定可以找到一个抽象事件覆盖它（至少几个树根节点构成的抽象事件—最抽象的事件—能够覆盖它）。在所有能覆盖这个集合的抽象事件中，那个最具体的抽象事件就是该集合的最小覆盖。</p>
<p>例如，数据集U的子集{1, 2}，可以覆盖这个集合的抽象事件有很多，最抽象的事件（日期，时间，老人类型）可以，抽象事件A &#x3D; （工作日，劳作时，行动老人）也可以覆盖，抽象事件B &#x3D; （工作日，上午劳作时，行动老人）也可以。但只有B是最小覆盖，因为它最具体。最小覆盖是唯一的。</p>
<h3 id="（五）覆盖集的松散度"><a href="#（五）覆盖集的松散度" class="headerlink" title="（五）覆盖集的松散度"></a><strong>（五）覆盖集的松散度</strong></h3><p>一个抽象事件距离它的覆盖集的距离的平均值，就是这个抽象事件的松散度。决定松散度的条件有两个，第一个是抽象事件，第二个是它覆盖的基础抽象数据集合。松散度的值随着二者的变化而变化。</p>
<p>例如，抽象事件A &#x3D; （工作日，劳作时，行动老人）可以覆盖U的子集{1, 2}，A的松散度是 ( 2&#x2F;3 + 2&#x2F;3) &#x2F; 2 &#x3D; 2&#x2F;3，抽象事件B &#x3D; （工作日，上午劳作时，行动老人）也可以覆盖U的子集子集{1, 2}，但B的松散度是 (1&#x2F;3 + 1&#x2F;3) &#x2F; 2 &#x3D; 1&#x2F;3。</p>
<h3 id="（六）一次聚类问题"><a href="#（六）一次聚类问题" class="headerlink" title="（六）一次聚类问题"></a><strong>（六）一次聚类问题</strong></h3><p>给定一个基础抽象事件集E，给定一个主题值的百分比阈值T（例如30%），以及松散度的阈值S（例如0.8）找出一个抽象事件A，使得A的覆盖集的主题值之和大于或等于阈值，且A的松散度值最小，且A的松散度的值不超过S。</p>
<p>例如，假设E就是集合U：</p>
<p>1 （周一，上午劳作时，行动老人，80）</p>
<p>2 （周二，上午劳作时，行动老人，90）</p>
<p>3 （周六，上午劳作时，活力老人，120）</p>
<p>4 （周日，下午劳作时，活力老人，100）</p>
<p>5 （周五，晚休闲，地上行动老人，70）</p>
<p>T设置为30%，S设置位0.8，则一次聚类问题可以找到的抽象事件是A &#x3D; （工作日，上午劳作时，行动老人），其主题值是80+90 &#x3D; 170, 其百分比是170 &#x2F; (80 + 90 + 120 + 100 + 70) &#x3D; 170 &#x2F; 440 &#x3D; 38.6% &gt; 30%, 满足阈值。其松散度是 1&#x2F;3，满足不超过0.8的条件，且最小。因此，一次层次化聚类得到的结果就是A &#x3D; （工作日，上午劳作时，行动老人）。</p>
<h3 id="（七）多次聚类问题"><a href="#（七）多次聚类问题" class="headerlink" title="（七）多次聚类问题"></a><strong>（七）多次聚类问题</strong></h3><p>多次层次聚类是在一次层次聚类的基础上循环完成的。例如，上述经过一次聚类，得到了聚类结果A &#x3D; （工作日，上午劳作时，行动老人）。</p>
<p>然后删除A的覆盖集，得到缩小了的集合，</p>
<p>3 （周六，上午劳作时，活力老人，120）</p>
<p>4 （周日，下午劳作时，活力老人，100）</p>
<p>5 （周五，晚休闲，地上行动老人，70）</p>
<p>继续寻找最好的抽象事件，我们可以发现B &#x3D; （休息日，劳作时，活力老人）满足条件。首先，它满足主题值阈值：(120 + 100) &#x2F; 440 &#x3D; 50%；其次，它的松散度是0.667 &lt; 0.8，并且它是在满足条件的抽象事件中，松散度最小的。</p>
<p>至此，第二轮的聚类工作完成。此时只剩一条数据：</p>
<p>5 （周五，晚休闲，地上行动老人，70）</p>
<p>显然，这条数据的最小覆盖就是（周五，晚休闲，地上行动老人），它的松散度很低，是0，但它并不满足主题值的阈值条件：70 &#x2F; 440 &#x3D; 15.9%，因此聚类结束。通过聚类，我们得到了两个抽象事件及其主题值：</p>
<p>（工作日，上午劳作时，行动老人, 170）和（休息日，劳作时，活力老人, 220）。<strong>这两个抽象事件代表着原数据中发生的主要事情，并且描述得又足够具体</strong>！</p>
<h2 id="2．输入输出及具体要求"><a href="#2．输入输出及具体要求" class="headerlink" title="2．输入输出及具体要求"></a>2．输入输出及具体要求</h2><p>输入：每个层次树文件作为输入，基础抽象数据集作为输入。</p>
<p>输出：按顺序打印出得到的若干个聚类。</p>
<p>例如，</p>
<p>“老人类型”树结构输入的文件如下（另外两棵树的文件内容略）：                    </p>
<p>0 ## -1 ## 老人类型</p>
<p>1 ## 0 ## 活力老人</p>
<p>2 ## 0 ## 行动老人</p>
<p>3 ## 0 ## 心动老人</p>
<p>4 ## 3 ## 地上心动老人</p>
<p>5 ## 3 ## 床上心动老人</p>
<p>输入的基础抽象事件集合如下：</p>
<p>（周一，上午劳作时，行动老人，80）</p>
<p>（周二，上午劳作时，行动老人，90）</p>
<p>（周六，上午劳作时，活力老人，120）</p>
<p>（周日，下午劳作时，活力老人，100）</p>
<p>（周五，晚休闲，地上行动老人，70）</p>
<p>输出的聚类集如下：</p>
<p>（工作日，上午劳作时，行动老人, 170）</p>
<p>（休息日，劳作时，活力老人, 220）</p>
<p><strong>本实验要求尽量用剪枝减少计算工作量，请在实验报告中说明你的剪枝策略</strong>。</p>
<p><strong>本实验语言不限，请大家尽力做好，要经得起大规模数据的测试</strong>。</p>
<h1 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h1><p>读入puechasing文件的数据并用arraylist存储购买记录，并将其转化为与树的叶子结点一致的内容。</p>
<p>Log类：</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package ex3;
public class Log &#123;
    private String data1;&#x2F;&#x2F;日期
    private String data2;&#x2F;&#x2F;时间
    private String data3;&#x2F;&#x2F;老人类型
    private double weight;
    public Log(String data1, String data2, String data3, double weight) &#123;
        this.data1&#x3D;data1;
        this.data2&#x3D;data2;
        this.data3&#x3D;data3;
        this.weight&#x3D;weight;
    &#125;
    public String getData1() &#123;
        return data1;
    &#125;
    public void setData1(String data1) &#123;
        this.data1 &#x3D; data1;
    &#125;
    public String getData2() &#123;
        return data2;
    &#125;
    public void setData2(String data2) &#123;
        this.data2 &#x3D; data2;
    &#125;
    public String getData3() &#123;
        return data3;
    &#125;
    public void setData3(String data3) &#123;
        this.data3 &#x3D; data3;
    &#125;
    public double getWeight() &#123;
        return weight;
    &#125;
    public void setWeight(double weight) &#123;
        this.weight &#x3D; weight;
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>XuanXiang类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">ex3</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XuanXiang</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> isFugai <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token number">50000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//loglength</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">50000</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> sumweight<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> distancesum<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> lisandu<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> fugaisum<span class="token punctuation">;</span>
    <span class="token comment">/*public int[] getIsFugai() &#123;
        return isFugai;
    &#125;
    public void setIsFugai(int isFugai[]) &#123;
        this.isFugai = isFugai;
    &#125;
    public int[] getIsConsider() &#123;
        return isConsider;
    &#125;
    public void setIsConsider(int isConsider[]) &#123;
        this.isConsider = isConsider;
    &#125;
    public int[][] getD() &#123;
        return d;
    &#125;
    public void setD(int d[][]) &#123;
        this.d = d;
    &#125;
    public double getSumweight() &#123;
        return sumweight;
    &#125;
    public void setSumweight(double sumweight) &#123;
        this.sumweight = sumweight;
    &#125;
    */</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>PTree类存储树的属性和方法:</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package ex3;
import java.util.*;
public class PTree &#123;
     int max&#x3D;100;
     int n,root;
     int a[]&#x3D;new int[max];&#x2F;&#x2F;用于存放孩子结点在数组中的位置
     PTNode nodes[]&#x3D;new PTNode[max];
     
     class PTNode&#123;
   	      String data;
   	      int parent;
   	      int child[]&#x3D;new int[100];&#x2F;&#x2F;假设一个节点最多有100个子孙
   	      int childnum&#x3D;0;
   	      public PTNode(String d,int p)&#123;
   		      this.data&#x3D;d;
   		      this.parent&#x3D;p; 
   	 &#125;
    &#125;
     public PTree()&#123;
    	 n&#x3D;0;
     &#125;
     public boolean isEmpty()&#123;  &#x2F;&#x2F;判断是否为空
    	 return n&#x3D;&#x3D;0;
     &#125;
     
     public PTNode assign(String d,int p)&#123; &#x2F;&#x2F;给结点赋值
   	    PTNode newNode&#x3D;new PTNode(d,p);
   	    return newNode;
    &#125;
     
     public void insert(String d,int p)&#123; &#x2F;&#x2F;添加新结点，给定结点位置
    	   nodes[n]&#x3D;assign(d,p);
    	   n++;
     &#125;
     
     
     public String getData(int i)&#123; &#x2F;&#x2F;返回序号为i的结点的数据
    	 if(i&gt;n)&#123;
    		 return null;
    	 &#125;
    	 return (String)nodes[i].data;
     &#125;
  
     
     public PTNode getParent(int p)&#123; &#x2F;&#x2F;返回父母结点,给定该结点位置
    	  int pare&#x3D;nodes[p].parent;
    	  return nodes[pare];
     &#125;
     public PTNode getParent(String d)&#123; &#x2F;&#x2F;返回父母结点，给定该结点data
    	 int p&#x3D;0;
    	 for(int i&#x3D;0;i&lt;n;i++)&#123;
    		 int x&#x3D;((String)(nodes[i].data)).compareTo((String)d);
    		 if(x&#x3D;&#x3D;0)
    			 p&#x3D;i;
    	 &#125;
    	 
   	  int pare&#x3D;nodes[p].parent;
   	  return nodes[pare];
    &#125;
     
     
     public String getParentData(int p)&#123; &#x2F;&#x2F;返回父母结点元素
    	 if(p&gt;n)&#123;
    		 return null;
    	 &#125;
    	   return (String)getParent(p).data;
     &#125;
     
     public int getChildCount(int p)&#123; &#x2F;&#x2F;返回孩子结点数
    	 int count&#x3D;0;    	 
    	 for(int i&#x3D;0;i&lt;n;i++)&#123;
    		 if(nodes[i].parent&#x3D;&#x3D;p)&#123;
    			 a[count]&#x3D;i;&#x2F;&#x2F;将该结点的孩子结点在数组中的位置存下来
    			 count++;
    		 &#125;
    	 &#125;
    	 return count;
     &#125;
     
     public int getChildCount(String d)&#123;&#x2F;&#x2F;返回孩子结点数,给定结点值
    	 int p&#x3D;0;
    	 for(int i&#x3D;0;i&lt;n;i++)&#123;
    		 int x&#x3D;((String)(nodes[i].data)).compareTo((String)d);
    		 if(x&#x3D;&#x3D;0)
    			 p&#x3D;i;
    	 &#125;
    	 int count&#x3D;0;    	 
    	 for(int i&#x3D;0;i&lt;n;i++)&#123;
    		 if(nodes[i].parent&#x3D;&#x3D;p)&#123;
    			 a[count]&#x3D;i;&#x2F;&#x2F;将该结点的孩子结点在数组中的位置存下来
    			 count++;
    		 &#125;
    	 &#125;
    	 return count;
     &#125;
     
     
     public PTNode getFirstChild(int p)&#123; &#x2F;&#x2F;获得第一个孩子结点
    	 int c&#x3D;getChildCount(p);&#x2F;&#x2F;得到孩子结点个数
    	 PTNode kong&#x3D;new PTNode(null,-2);
    	 if(c&#x3D;&#x3D;0)&#123;
    		 return kong;
    	 &#125;
    	 else&#123;
    		 return nodes[a[0]];
    	 &#125;	 
     &#125;
     
     public int depth()&#123;
    	int max&#x3D;0,height,p&#x3D;0;&#x2F;&#x2F;max记录当前的最大高度，p记录双亲结点的位置，height为当前的深度
    	for(int i&#x3D;0;i&lt;n;i++)&#123;
    		height&#x3D;1;               &#x2F;&#x2F;每次循环开始，初始化height
    		p&#x3D;nodes[i].parent;
    		while(p!&#x3D;-1)&#123;         &#x2F;&#x2F;若当前结点不是根结点，执行此循环
     			p&#x3D;nodes[p].parent;      &#x2F;&#x2F;不断沿双亲结点向上走
     			height++;               &#x2F;&#x2F;没向上一步，高度加一
    		&#125;
    		if(height&gt;max)           &#x2F;&#x2F;记录当前最大深度
    			max&#x3D;height;
    	&#125;
    	return max;
     &#125;
     public int getDepth(int m)&#123;&#x2F;&#x2F;获得某一结点所处的层次,根节点层次记为1
    	 if(m&gt;&#x3D;n)
    		 return 0;
    	 int height&#x3D;1,p&#x3D;0;
     	 height&#x3D;1;               &#x2F;&#x2F;每次循环开始，初始化height
     	p&#x3D;nodes[m].parent;
     	while(p!&#x3D;-1)&#123;         &#x2F;&#x2F;若当前结点不是根结点，执行此循环
      		p&#x3D;nodes[p].parent;      &#x2F;&#x2F;不断沿双亲结点向上走
      		height++;               &#x2F;&#x2F;没向上一步，高度加一
     	&#125;
     	return height;
     &#125;
     public int distance(int m,int n) &#123;&#x2F;&#x2F;判断m是否覆盖n,不覆盖返回-1,覆盖返回距离差
    	 if(m&#x3D;&#x3D;n) return 0;
    	 int p&#x3D;nodes[n].parent;
    	 if(p&#x3D;&#x3D;m) return 1;
    	 if(p&#x3D;&#x3D;-1) return -1;
    	 int count&#x3D;0;
    	 while(true) &#123;
    		 count++;
    		 p&#x3D;nodes[p].parent;
    		 if(p&#x3D;&#x3D;m) return 1+count;
    		 if(p&#x3D;&#x3D;-1) return -1;
    	 &#125;
     &#125;
     public int xuHao(String data) &#123;&#x2F;&#x2F;根据节点数据返回节点编号
    	 for(int i&#x3D;0;i&lt;n;i++) &#123;
    		 if(nodes[i].data.equals(data)) return i;
    	 &#125;
    	 return -1;
     &#125;
     public void child(int m) &#123;&#x2F;&#x2F;填写m号节点的child数组，m号节点和他的子孙节点的编号都被填入其中
    	 for(int i&#x3D;0;i&lt;n;i++) &#123;
    		 if(distance(m,i)!&#x3D;-1) &#123;
     			 nodes[m].child[nodes[m].childnum]&#x3D;i;
    			 nodes[m].childnum++;
    		 &#125;
    	 &#125;
     &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>三维对象数组存储三棵树的各节点所能表示的所有抽象事件的集合</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;待选抽象事件集合
XuanXiangkexuanxiang[][][]&#x3D;newXuanXiang[length_date][length_time][length_laoren];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>遍历kexuanxiang对象数组，与log数组中的各条记录进行比较判断是否覆盖，如果能覆盖就计算离散度和主题值阈值，判断主题值阈值和离散度是否达标如果达标就与最小达标离散度进行比较，更新当前的最优解。循环结束后输出最优的覆盖集，一次聚类结束。多次聚类时，由于在第一次计算时已经计算好了kexuanxiang对象数组的覆盖集，离散度，主题值，再次聚类只需在上次聚类的结果上剔除部分已经被聚类掉的数据即可。判断主题值阈值是否达标时，如果不达标，计算当前对象数组的各个节点的孩子以及孙子节点将他们从循环中剔除，可以证明如果nodei和nodej以及nodek组成的节点主题值阈值不够，则他们各自的子节点所形成的子节点在多次聚类中均无法达到主题值阈值的要求，故不予考虑。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package ex3;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;



public class Test &#123;
    
    public static String dateToWeek(String datetime) &#123;
        SimpleDateFormat f &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        String[] weekDays &#x3D; &#123; &quot;周天&quot;, &quot;周一&quot;, &quot;周二&quot;, &quot;周三&quot;, &quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot; &#125;;
        Calendar cal &#x3D; Calendar.getInstance(); &#x2F;&#x2F; 获得一个日历
        Date datet &#x3D; null;
        try &#123;
            datet &#x3D; f.parse(datetime);
            cal.setTime(datet);
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        int w &#x3D; cal.get(Calendar.DAY_OF_WEEK) - 1; &#x2F;&#x2F; 指示一个星期中的某天。
        if (w &lt; 0)
            w &#x3D; 0;
        return weekDays[w];
    &#125;
    public static void main(String[] args) &#123;
        System.out.println(Test.dateToWeek(&quot;2019-5-14&quot;));
        &#x2F;&#x2F; TODO Auto-generated method stub
        try &#123;
            &#x2F;&#x2F;读入数据
            BufferedReader br&#x3D;new BufferedReader(new FileReader(&quot;H:&#x2F;laoren.txt&quot;));
            String s;
            &#x2F;&#x2F;老人树的构建
            PTree laoren &#x3D; new PTree();
            while((s&#x3D;br.readLine())!&#x3D;null) &#123;
                String []strArr&#x3D;s.split(&quot; ## &quot;);
                laoren.insert(strArr[2],Integer.parseInt(strArr[1]));
            &#125;
            for(int i&#x3D;0;i&lt;laoren.n;i++) &#123;
                System.out.println(laoren.nodes[i].parent+laoren.nodes[i].data);
            &#125;
            System.out.println(laoren.n);
            &#x2F;&#x2F;日期树的构建
            br&#x3D;new BufferedReader(new FileReader(&quot;H:&#x2F;date.txt&quot;));
            PTree date &#x3D; new PTree();
            while((s&#x3D;br.readLine())!&#x3D;null) &#123;
                String []strArr&#x3D;s.split(&quot; ## &quot;);
                date.insert(strArr[2],Integer.parseInt(strArr[1]));
            &#125;
            for(int i&#x3D;0;i&lt;date.n;i++) &#123;
                System.out.println(date.nodes[i].parent+date.nodes[i].data);
            &#125;
            System.out.println(date.n);
            &#x2F;&#x2F;时间树的构建
            br&#x3D;new BufferedReader(new FileReader(&quot;H:&#x2F;time.txt&quot;));
            PTree time &#x3D; new PTree();
            while((s&#x3D;br.readLine())!&#x3D;null) &#123;
                String []strArr&#x3D;s.split(&quot; ## &quot;);
                time.insert(strArr[2],Integer.parseInt(strArr[1]));
            &#125;
            for(int i&#x3D;0;i&lt;time.n;i++) &#123;
                System.out.println(time.nodes[i].parent+time.nodes[i].data);
            &#125;
            System.out.println(time.n);
            &#x2F;&#x2F;基本数据项的读入
            br&#x3D;new BufferedReader(new FileReader(&quot;H:&#x2F;purchasingLog.txt&quot;));
            ArrayList&lt;Log&gt; log &#x3D; new ArrayList&lt;Log&gt;();&#x2F;&#x2F;log数组
            while((s&#x3D;br.readLine())!&#x3D;null) &#123;
                String []strArr&#x3D;s.split(&quot;, &quot;);
                String tempdata1;
                String tempdata2;
                String tempdata3;
                double tempweight;
                &#x2F;&#x2F;??string转double是否正确??
                tempweight&#x3D;Double.parseDouble(strArr[2]);
                int age&#x3D;Integer.parseInt(strArr[1]);
                &#x2F;&#x2F;假设没有错误的年龄数据，比如大于99或者小与60
                if(age&lt;&#x3D;69) tempdata3&#x3D;&quot;活力老人&quot;;
                else if(age&lt;&#x3D;79) tempdata3&#x3D;&quot;行动老人&quot;;
                else if(age&lt;&#x3D;89) tempdata3&#x3D;&quot;地上心动老人&quot;;
                else tempdata3&#x3D;&quot;床上心动老人&quot;;
                &#x2F;&#x2F;时间戳的分隔与转换
                String []strArr2&#x3D;strArr[0].split(&quot;T&quot;);
                &#x2F;&#x2F;strArr2[0]日期信息
                String []strArr3&#x3D;strArr2[1].split(&quot;:&quot;);&#x2F;&#x2F;19:54:14
                int temptime&#x3D;Integer.parseInt(strArr3[0]);
                if(temptime&lt;8) tempdata2&#x3D;&quot;早休闲&quot;;
                else if(temptime&lt;&#x3D;11) tempdata2&#x3D;&quot;上午劳作时&quot;;
                else if(temptime&#x3D;&#x3D;12) tempdata2&#x3D;&quot;午休闲&quot;;
                else if(temptime&lt;&#x3D;16) tempdata2&#x3D;&quot;下午劳作时&quot;;
                else tempdata2&#x3D;&quot;晚休闲&quot;;
                tempdata1&#x3D;Test.dateToWeek(strArr2[0]);
                Log temp&#x3D;new Log(tempdata1,tempdata2,tempdata3,tempweight);
                log.add(temp);
            &#125;
            &#x2F;*for(int i&#x3D;0;i&lt;10;i++) &#123;
                System.out.println(log.get(i).getData1()+&quot; &quot;+&quot; &quot;+log.get(i).getData2()+&quot; &quot;+log.get(i).getData3()+&quot; &quot;+log.get(i).getWeight());
            &#125;
            System.out.println(log.size());*&#x2F;
            &#x2F;&#x2F;基本数据项的处理
            double T&#x3D;0.3;
            double S&#x3D;0.8;
            
            double logweightsum&#x3D;0;
            for(int i&#x3D;0;i&lt;log.size();i++) &#123;
                logweightsum&#x3D;logweightsum+log.get(i).getWeight();
            &#125;
            System.out.println(logweightsum);
            T&#x3D;T*logweightsum;
            System.out.println(&quot;T:&quot;+T+&quot;S:&quot;+S);
            &#x2F;&#x2F;每棵树的节点数
            int length_date&#x3D;date.n;
            int length_time&#x3D;time.n;
            int length_laoren&#x3D;laoren.n;
            System.out.println(length_date+&quot; &quot;+length_time+&quot; &quot;+length_laoren);
            &#x2F;&#x2F;待选抽象事件集合
            XuanXiang  kexuanxiang[][][]&#x3D; new XuanXiang[length_date][length_time][length_laoren];
            &#x2F;&#x2F;初始化kexuanxiang[i][j[[k]
            for(int i&#x3D;0;i&lt;length_date;i++) &#123;
                for(int j&#x3D;0;j&lt;length_time;j++) &#123;
                    for(int k&#x3D;0;k&lt;length_laoren;k++) &#123;
                        &#x2F;&#x2F;对象数组创建完后要对每一个数组对象new一下
                        kexuanxiang[i][j][k]&#x3D;new XuanXiang();
                        kexuanxiang[i][j][k].sumweight&#x3D;0.0;
                        kexuanxiang[i][j][k].distancesum&#x3D;0.0;
                        kexuanxiang[i][j][k].lisandu&#x3D;0.0;
                        kexuanxiang[i][j][k].fugaisum&#x3D;0;
                        &#x2F;&#x2F;idfugai
                        &#x2F;&#x2F;isconsider
                        &#x2F;&#x2F;d[][]
                    &#125;
                &#125;
            &#125;
            double minlisandu&#x3D;100;&#x2F;&#x2F;假设所有的松散度都大于100???设的比最大树高高就好
            int besti&#x3D;-1,bestj&#x3D;-1,bestk&#x3D;-1;
            System.out.println(&quot;bestvalue&quot;+besti+bestj+bestk);
            int delete[][][]&#x3D;new int[length_date][length_time][length_laoren];&#x2F;&#x2F;存储剪枝节点delete[i][j][k]&#x3D;1,表示kexuanxiang[i][j][k]在之后的算法流程中不予考虑
            for(int i&#x3D;0;i&lt;length_date;i++) &#123;
                for(int j&#x3D;0;j&lt;length_time;j++) &#123;
                    for(int k&#x3D;0;k&lt;length_laoren;k++) &#123;
                        delete[i][j][k]&#x3D;0;
                    &#125;
                &#125;
            &#125;
            &#x2F;&#x2F;测试
            &#x2F;*for(int i&#x3D;0;i&lt;date.n;i++) &#123;
                for(int j&#x3D;0;j&lt;date.n;j++) &#123;
                    System.out.println(i+&quot; &quot;+&quot; &quot;+j+&quot; &quot;+date.distance(i, j));
                &#125;
            &#125;*&#x2F;
            &#x2F;&#x2F;求每个树的子节点
            for(int i&#x3D;0;i&lt;length_date;i++) &#123;
                date.child(i);
            &#125;
            for(int j&#x3D;0;j&lt;length_time;j++) &#123;
                time.child(j);
            &#125;
            for(int k&#x3D;0;k&lt;length_laoren;k++) &#123;
                laoren.child(k);
            &#125;
            
            for(int i&#x3D;0;i&lt;length_date;i++) &#123;
                for(int j&#x3D;0;j&lt;length_time;j++) &#123;
                    for(int k&#x3D;0;k&lt;length_laoren;k++) &#123;
                        if(delete[i][j][k]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;剪枝
                        for(int l&#x3D;0;l&lt;log.size();l++) &#123;
                            if(date.distance(i,date.xuHao(log.get(l).getData1()))&#x3D;&#x3D;-1||time.distance(j,time.xuHao(log.get(l).getData2()))&#x3D;&#x3D;-1||laoren.distance(k,laoren.xuHao(log.get(l).getData3()))&#x3D;&#x3D;-1) &#123;
                                kexuanxiang[i][j][k].isFugai[l]&#x3D;0;
                                &#x2F;&#x2F;kexuanxiang[i][j][k]不覆盖log.get(l),距离也不需要考虑
                            &#125;
                            else &#123;
                                kexuanxiang[i][j][k].isFugai[l]&#x3D;1;
                                kexuanxiang[i][j][k].d[l][0]&#x3D;date.distance(i, date.xuHao(log.get(l).getData1()));
                                kexuanxiang[i][j][k].d[l][1]&#x3D;time.distance(j,time.xuHao(log.get(l).getData2()));
                                kexuanxiang[i][j][k].d[l][2]&#x3D;laoren.distance(k,laoren.xuHao(log.get(l).getData3()));
                                kexuanxiang[i][j][k].sumweight&#x3D;kexuanxiang[i][j][k].sumweight+log.get(l).getWeight();
                                kexuanxiang[i][j][k].distancesum&#x3D;kexuanxiang[i][j][k].distancesum+(kexuanxiang[i][j][k].d[l][0]+kexuanxiang[i][j][k].d[l][1]+kexuanxiang[i][j][k].d[l][2])&#x2F;3.0;
                                kexuanxiang[i][j][k].fugaisum++;
                                
                            &#125;
                        &#125;
                        &#x2F;&#x2F;得到kexuanxiang的fugaisum和sumweight, 现在计算lisandu
                        kexuanxiang[i][j][k].lisandu&#x3D;kexuanxiang[i][j][k].distancesum&#x2F;(double)kexuanxiang[i][j][k].fugaisum;
                        &#x2F;&#x2F;判断kexuanxiang的S和T是否达到要求
                        if(kexuanxiang[i][j][k].sumweight&lt;T) &#123;&#x2F;&#x2F;如果主题值阈值达不到要求，对ijk的子节点进行剪枝
                            delete[i][j][k]&#x3D;1;
                            for(int m&#x3D;0;m&lt;date.nodes[i].childnum;m++) &#123;
                                for(int n&#x3D;0;n&lt;time.nodes[j].childnum;n++) &#123;
                                    for(int o&#x3D;0;o&lt;laoren.nodes[o].childnum;o++) &#123;
                                        delete[date.nodes[i].child[m]][time.nodes[j].child[n]][laoren.nodes[k].child[o]]&#x3D;1;
                                    &#125;
                                &#125;
                            &#125;
                        &#125;
                        else if(kexuanxiang[i][j][k].lisandu&lt;&#x3D;S) &#123;
                            if(kexuanxiang[i][j][k].lisandu&lt;minlisandu) &#123;
                                besti&#x3D;i;
                                bestj&#x3D;j;
                                bestk&#x3D;k;
                                minlisandu&#x3D;kexuanxiang[i][j][k].lisandu;
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;
            System.out.println(besti);
            if(besti&#x3D;&#x3D;-1&amp;&amp;bestj&#x3D;&#x3D;-1&amp;&amp;bestk&#x3D;&#x3D;-1) &#123;
                System.out.println(&quot;没有满足主题值阈值和离散度阈值的聚类&quot;);
                System.exit(0);
            &#125;
            else System.out.println(&quot;一次聚类的结果为&quot;+date.nodes[besti].data+time.nodes[bestj].data+laoren.nodes[bestk].data+kexuanxiang[besti][bestj][bestk].sumweight);
            int fugaiji[]&#x3D;new int [10000];&#x2F;&#x2F;假设当前聚类的最优解的覆盖log的数目不超过10000
            int fugaijilength&#x3D;0;
            &#x2F;&#x2F;存储当前聚类得到的最优解的覆盖集
            for(int i&#x3D;0;i&lt;10000;i++) &#123;
                if(kexuanxiang[besti][bestj][bestk].isFugai[i]&#x3D;&#x3D;1) &#123;
                    fugaiji[fugaijilength]&#x3D;i;
                    fugaijilength++;
                &#125;
            &#125;
            &#x2F;&#x2F;多次聚类
            while(true) &#123;
                minlisandu&#x3D;100;
                besti&#x3D;-1;
                bestj&#x3D;-1;
                bestk&#x3D;-1;
                for(int i&#x3D;0;i&lt;length_date;i++) &#123;
                    for(int j&#x3D;0;j&lt;length_time;j++) &#123;
                        for(int k&#x3D;0;k&lt;length_laoren;k++) &#123;
                            if(delete[i][j][k]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;剪枝
                            for(int l&#x3D;0;l&lt;fugaijilength;l++) &#123;
                                if(kexuanxiang[i][j][k].isFugai[fugaiji[l]]&#x3D;&#x3D;1) &#123;
                                    &#x2F;&#x2F;???idfugai要修改吗??
                                    kexuanxiang[i][j][k].isFugai[fugaiji[l]]&#x3D;0;
                                    kexuanxiang[i][j][k].fugaisum--;
                                    kexuanxiang[i][j][k].sumweight&#x3D;kexuanxiang[i][j][k].sumweight-log.get(fugaiji[l]).getWeight();
                                    kexuanxiang[i][j][k].distancesum&#x3D;kexuanxiang[i][j][k].distancesum-(kexuanxiang[i][j][k].d[fugaiji[l]][0]+kexuanxiang[i][j][k].d[fugaiji[l]][1]+kexuanxiang[i][j][k].d[fugaiji[l]][2])&#x2F;3.0;
                                &#125;
                            &#125;
                            kexuanxiang[i][j][k].lisandu&#x3D;kexuanxiang[i][j][k].distancesum&#x2F;kexuanxiang[i][j][k].fugaisum;
                            if(kexuanxiang[i][j][k].sumweight&lt;T) &#123;
                                delete[i][j][k]&#x3D;1;
                                for(int m&#x3D;0;m&lt;date.nodes[i].childnum;m++) &#123;
                                    for(int n&#x3D;0;n&lt;time.nodes[j].childnum;n++) &#123;
                                        for(int o&#x3D;0;o&lt;laoren.nodes[o].childnum;o++) &#123;
                                            delete[date.nodes[i].child[m]][time.nodes[j].child[n]][laoren.nodes[k].child[o]]&#x3D;1;
                                        &#125;
                                    &#125;
                                &#125;
                            &#125;
                            else if(kexuanxiang[i][j][k].lisandu&lt;&#x3D;S) &#123;
                                if(kexuanxiang[i][j][k].lisandu&lt;minlisandu) &#123;
                                    besti&#x3D;i;
                                    bestj&#x3D;j;
                                    bestk&#x3D;k;
                                    minlisandu&#x3D;kexuanxiang[i][j][k].lisandu;
                                &#125;
                            &#125;
                        &#125;
                    &#125;
                &#125;
                if(besti&#x3D;&#x3D;-1&amp;&amp;bestj&#x3D;&#x3D;-1&amp;&amp;bestk&#x3D;&#x3D;-1) &#123;
                    System.out.println(&quot;没有满足主题值阈值和离散度阈值的聚类了&quot;);
                    break;
                &#125;
                else System.out.println(&quot;聚类的结果为&quot;+date.nodes[besti].data+time.nodes[bestj].data+laoren.nodes[bestk].data+kexuanxiang[besti][bestj][bestk].sumweight);
                
                fugaijilength&#x3D;0;
                for(int i&#x3D;0;i&lt;10000;i++) &#123;
                    if(kexuanxiang[besti][bestj][bestk].isFugai[i]&#x3D;&#x3D;1) &#123;
                        fugaiji[fugaijilength]&#x3D;i;
                        fugaijilength++;
                    &#125;
                &#125;
            &#125;
            &#x2F;&#x2F;
        &#125;catch(IOException e) &#123;
            System.out.println(e.getMessage());
        &#125; 
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="实验结果及结论分析："><a href="#实验结果及结论分析：" class="headerlink" title="实验结果及结论分析："></a>实验结果及结论分析：</h1><p>遍历kexuanxiang对象数组，与log数组中的各条记录进行比较判断是否覆盖，如果能覆盖就计算离散度和主题值阈值，判断主题值阈值和离散度是否达标如果达标就与最小达标离散度进行比较，更新当前的最优解。循环结束后输出最优的覆盖集，一次聚类结束。多次聚类时，由于在第一次计算时已经计算好了kexuanxiang对象数组的覆盖集，离散度，主题值，再次聚类只需在上次聚类的结果上剔除部分已经被聚类掉的数据即可。判断主题值阈值是否达标时，如果不达标，计算当前对象数组的各个节点的孩子以及孙子节点将他们从循环中剔除，可以证明如果nodei和nodej以及nodek组成的节点主题值阈值不够，则他们各自的子节点所形成的子节点在多次聚类中均无法达到主题值阈值的要求，故不予考虑。</p>
<p>实验的输出如下：</p>
<p><img src="/img/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%894.png"></p>
<p>通过剪枝以及减少循环体内的数据操作，程序的性能得到了极大的提高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/12/%E5%B1%82%E6%AC%A1%E5%8C%96%E8%81%9A%E7%B1%BB/" data-id="cl4edhdps003n0ox3a4p9cvdf" data-title="层次化聚类" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/12/pageRank/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PageRank算法的应用：
        
      </div>
    </a>
  
  
    <a href="/2020/03/12/JavaWeb%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JavaWeb:个人简历管理平台</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWeb/">JavaWeb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unity/">Unity</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/postgreGIS/">postgreGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/">实习总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E8%A1%8C/">并行</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">数字图像处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">时空数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%80%E5%BF%AB%E8%B7%AF%E5%BE%84/">最快路径</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4/">隐私保护</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qgis/" rel="tag">Qgis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postgreGIS/" rel="tag">postgreGIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zset/" rel="tag">zset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B1%E7%8E%B0%E5%85%B3%E7%B3%BB/" rel="tag">共现关系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" rel="tag">动态网页</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE/" rel="tag">团队项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/" rel="tag">实习总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/" rel="tag">差分隐私</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/" rel="tag">并行算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">持久化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">数字图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" rel="tag">数据备份</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">时空数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%BF%AB%E8%B7%AF%E5%BE%84/" rel="tag">最快路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" rel="tag">最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/" rel="tag">有序集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9F%A5%E8%AF%A2/" rel="tag">查询</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%B3%E8%A1%A8/" rel="tag">跳表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/" rel="tag">软件开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/JavaWeb/" style="font-size: 10px;">JavaWeb</a> <a href="/tags/Qgis/" style="font-size: 10px;">Qgis</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/postgreGIS/" style="font-size: 10px;">postgreGIS</a> <a href="/tags/zset/" style="font-size: 10px;">zset</a> <a href="/tags/%E5%85%B1%E7%8E%B0%E5%85%B3%E7%B3%BB/" style="font-size: 10px;">共现关系</a> <a href="/tags/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/" style="font-size: 10px;">动态网页</a> <a href="/tags/%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">团队项目</a> <a href="/tags/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/" style="font-size: 10px;">实习总结</a> <a href="/tags/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/" style="font-size: 15px;">差分隐私</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">并行算法</a> <a href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" style="font-size: 10px;">持久化</a> <a href="/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 10px;">数字图像处理</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" style="font-size: 10px;">数据备份</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 20px;">数据挖掘</a> <a href="/tags/%E6%97%B6%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 20px;">时空数据库</a> <a href="/tags/%E6%9C%80%E5%BF%AB%E8%B7%AF%E5%BE%84/" style="font-size: 15px;">最快路径</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 15px;">最短路径</a> <a href="/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/" style="font-size: 10px;">有序集合</a> <a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 10px;">查询</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E8%B7%B3%E8%A1%A8/" style="font-size: 10px;">跳表</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/" style="font-size: 10px;">软件开发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/24/parallel%20sssp/">单源最短路径算法的并行化</a>
          </li>
        
          <li>
            <a href="/2022/02/25/Go%20%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0/">Go并发：控制多个线程中部分功能的执行顺序</a>
          </li>
        
          <li>
            <a href="/2022/02/25/Go%E5%93%B2%E5%AD%A6%E8%80%85%E5%B0%B1%E9%A4%90/">使用Golang并发工具包解决哲学者就餐问题</a>
          </li>
        
          <li>
            <a href="/2022/02/23/%E5%95%86%E6%B1%A4%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/">商汤实习总结</a>
          </li>
        
          <li>
            <a href="/2021/08/10/Redis%E8%B7%B3%E8%A1%A8/">Redis跳表</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 RunZhe He<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>